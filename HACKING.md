## 1. Project scope & guarantees

**Primary goals**

* Provide **BSD-style `fts(3)`**, **GNU `obstack`**, and **glibc `argp`** APIs on musl without dragging in glibc or libiberty
* Keep **ABI close to NetBSD/OpenBSD and glibc** where applicable (especially `FTSENT` layout and obstack internals)
* Build cleanly as **C99** (`-std=c99 -pedantic`) with **Clang and GCC** on musl
* Depend only on **POSIX.1-2008**, not glibc extensions

Reference implementations:

* `fts`: NetBSD `fts(3)` manual + NetBSD/FreeBSD `fts.c` implementations([NetBSD Manual Pages][1])
* `obstack`: GNU C Library / gnulib `obstack.c` + `obstack.h` and manual sections([GitHub][2])
* `argp`: glibc `argp-parse.c` and manual, gnulib `argp-parse.c`([Sourceware][3])
* `queue.h` / `tree.h`: OpenBSD `sys/queue.h` and manpage([GitHub][4])

Existing musl ecosystem packages (`musl-fts`, `musl-obstack`, `argp-standalone`, `bsd-headers`) are good behavioral baselines, but the point of **musl-bsd** is to *unify* and modernize them instead of copy-paste([GitHub][5])

---

## 2. Coding & style guidelines

High level:

* **Language**: C99 only, no extensions in public headers
* **Warnings**: `-Wall -Wextra -Werror` mandatory (you already mention `warn_level=2`)
* **Toolchains**: tested at minimum with `clang`, `gcc` (latest two majors of each)
* **Threading**: libraries are reentrant where upstream is; no added global state

Concrete rules:

* Public headers compile with `-std=c99 -pedantic -Werror` and *no* `__attribute__` or compiler extensions unless gated through `cdefs.h`
* Internal code can use `__attribute__` and compiler builtins, but **always** behind feature-test macros generated by Meson (`config.h`)
* No VLA in public ABI structures; avoid surprising VLAs internally too
* Use `_Static_assert` in C99 via macro wrapper when available; gate via `cdefs.h`

---

## 3. ABI guidelines per component

### 3.1 libfts

**ABI target**

* Use **NetBSD `FTS` and `FTSENT` layout** as the canonical ABI  
  You can extract field order and types from NetBSD headers and manpage, and freeze that as your ABI contract([NetBSD Manual Pages][1])
* Do *not* attempt to match glibc's historical ABI - musl explicitly calls it "unusably broken"([musl libc][6])

**Rules**

* Keep `struct FTSENT` layout **byte-for-byte identical** to your chosen NetBSD snapshot:

  * Same field order
  * Same field types
  * Same `short` / `u_short` widths, padding, and alignment
* Add a small CI tool that runs `pahole` (or `clang -fdump-record-layouts`) on a glibc or BSD build and compares offsets to your musl build

**Semantics to match**

From NetBSD `fts(3)` and reference `fts.c`:([NetBSD Manual Pages][1])

* Implement all five core functions:

  * `fts_open`, `fts_read`, `fts_children`, `fts_set`, `fts_close`
* Implement all core flags:

  * traversal: `FTS_LOGICAL`, `FTS_PHYSICAL`, `FTS_COMFOLLOW`
  * behavior: `FTS_NOCHDIR`, `FTS_XDEV`, `FTS_SEEDOT`, `FTS_NOSTAT`, `FTS_WHITEOUT`
* Match traversal order:

  * Preorder entries (`FTS_D`) followed by optional postorder (`FTS_DP`)
  * `FTS_ERR`, `FTS_DNR`, and `FTS_NS` exactly as documented for errors / non-readable dirs / `stat` failure
* Cycle detection:

  * Maintain a dev+ino hash set to detect dir loops (like BSD and gnulib do)
  * Set `FTSENT->fts_cycle` to point to the earlier entry on detection
* Path handling:

  * `fts_path` must be a stable pointer to an internal buffer that's valid until next `fts_read`
  * Use dynamic path buffers with `PATH_MAX` fallback when defined, but never *assume* `PATH_MAX` exists (musl can omit it depending on feature macros)([musl libc][6])

**musl-specific guidance**

* Use only:

  * `openat`, `fstatat`, `fdopendir`, `readdir`, `closedir`, `readlinkat`, `getcwd`
* Do **not** rely on glibc-specific `d_type` behavior or `NAME_MAX` if you can avoid it
* Ensure the code builds and works identically on glibc - but treat glibc as a *test platform*, not ABI target

---

### 3.2 libobstack

**ABI target**

* Base on **GNU `obstack` layout and API** as in `glibc` / `gnulib`([GitHub][2])
* Provide the full public set:

  * `struct obstack`
  * `_obstack_begin`, `_obstack_begin_1`, `_obstack_newchunk`
  * `obstack_alloc`, `obstack_copy`, `obstack_copy0`, `obstack_grow`, `obstack_grow0`
  * `obstack_free`, `obstack_blank`, `obstack_blank_fast`
  * `obstack_printf`, `obstack_vprintf`
  * `obstack_alloc_failed_handler`

**Layout & hooks**

* Copy **struct layout** and macro interface from a known LGPL-compatible snapshot of `obstack.h` (glibc or gnulib) and treat it as ABI-frozen([CodeBrowser][7])
* Implement all worker functions (`_obstack_begin_worker`, `_obstack_newchunk`) as C functions exactly matching glibc prototypes
* Make **allocator hooks** first-class:

  * `(*chunk_alloc)(long)` / `(*chunk_free)(void *)` available to user
  * Provide thin wrappers that default to `malloc` / `free` but accept overrides for embedded/custom allocators

**Semantics**

From the GNU manual and reference code:([GNU FTP][8])

* Every operation must preserve the invariant that:

  * `obstack_next_free` points at the first free byte
  * `obstack_object_base` points at beginning of current object
* `obstack_free(obstack, obj)`:

  * If `obj` is `NULL`, free *everything* and reset obstack
  * Otherwise free all chunks above the one containing `obj` and discard objects above it within that chunk
* On OOM, call `(*obstack_alloc_failed_handler)()`; default handler calls `abort()`
* Define thread-safety expectations:

  * Document that **a single `struct obstack` must not be shared across threads without external synchronization**, matching glibc behavior

---

### 3.3 argp (libargp)

**ABI target**

* Same struct layouts and API signatures as glibc's argp: `struct argp`, `struct argp_option`, `struct argp_state`, and `argp_parse`([Sourceware][3])
* Behavior compatible with `argp-standalone`, which is the de facto argp provider on musl-based distributions([Repology][9])

**Semantics to match**

From glibc manual and source:

* Support:

  * hierarchical parsers via `struct argp` chains (`next`, `children`)
  * keys: `KEY_ARG`, `KEY_END`, `KEY_SUCCESS`, `KEY_FAILURE`, `KEY_INIT`, `KEY_FINI`
* `argp_parse` behavior:

  * Use `getopt_long`-style parsing underneath
  * Respect `ARGP_NO_EXIT`, `ARGP_IN_ORDER`, `ARGP_LONG_ONLY`, `ARGP_NO_HELP`, etc
  * Update `argp_state->next`, `argc`, `argv`, `arg_num` exactly as glibc does
* Help and error handling:

  * Implement `argp_help` and `argp_error` semantics
  * Honor `ARGP_HELP_FMT` env var formatting knobs (width, indentation, etc)([Sourceware][3])

**Implementation detail**

* Internally, copy the overall structure of gnulib's `argp-parse.c` but refactor to modern C99, removing legacy conditionals while preserving behavior([GitHub][10])
* Use `strerror_r`, `snprintf`, etc, instead of deprecated interfaces

---

### 3.4 queue.h / tree.h / cdefs.h

**queue.h / tree.h**

* Start from a modern OpenBSD `sys/queue.h` snapshot (and `sys/tree.h` if you add it)([GitHub][4])
* Strip or gate any constructs that are not C99-pedantic-safe:

  * use only standard C constructs in public macros; avoid `__typeof__`, `__inline`, etc unless wrapped by `cdefs.h`
* Preserve macro names and semantics so existing BSD consumers compile unchanged:

  * `SLIST_*`, `LIST_*`, `TAILQ_*`, `CIRCLEQ_*` (if you keep circle queues)
* Add small tests that:

  * Instantiate each list/queue/TAILQ type
  * Perform insert/delete/foreach
  * Compile with `-std=c99 -pedantic -Werror`

**cdefs.h**

* Provide the standard BSD-style macro surface:

  * `__BEGIN_DECLS` / `__END_DECLS`
  * `__dead`, `__pure`, `__unused`, `__packed`, `__aligned`, `__section`, etc, but implemented in terms of C99 and portable attributes
* Use feature detection:

  * Prefer `_Noreturn` in C11 mode, fall back to compiler attributes otherwise
  * Use `__has_attribute` when available, otherwise `__GNUC__` checks

Example pattern (just style, not exact names):

```
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
# define __bsd_noreturn _Noreturn
#elif defined(__GNUC__) || defined(__clang__)
# define __bsd_noreturn __attribute__((__noreturn__))
#else
# define __bsd_noreturn
#endif

#define __dead __bsd_noreturn
```

Backfill `static_assert`:

```
#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
# define __bsd_static_assert _Static_assert
#else
# define __bsd_static_assert(expr, msg) typedef char __bsd_static_assertion[(expr) ? 1 : -1]
#endif
```

---

## 4. Build & Meson guidelines

You already have a Meson-based workflow; here's how I'd structure the project logic.

**Subprojects / subdirs**

* `src/fts/` -> builds `libfts`
* `src/obstack/` -> builds `libobstack`
* `src/argp/` -> builds `libargp`
* `include/` -> flat header namespace (`fts.h`, `obstack.h`, `argp.h`, `queue.h`, `tree.h`, `cdefs.h`)
* `include/musl-bsd/` (optional) -> internal config and helper headers

**Meson options**

* `-Dfts=true/false`
* `-Dobstack=true/false`
* `-Dargp=true/false`
* `-Ddefault_library=shared|static`

**Config header**

Generate a `config.h` with Meson detection:

* `HAVE__NORETURN`
* `HAVE___ATTRIBUTE__NORETURN__`
* `HAVE_BUILTIN_EXPECT`
* `HAVE_DECL_ENVIRON`
* `HAVE_FSTATAT`, `HAVE_OPENAT`, `HAVE_READLINKAT`

Then `cdefs.h` and internal headers map these to exported macros. No `autoconf`-style soup, just the minimum needed.

**Symbol visibility**

* Use `-fvisibility=hidden` by default and export only the official APIs with `__attribute__((visibility("default")))` gated through `cdefs.h`
* Provide a linker version script for ELF platforms to limit exports:

  * one block per library (`LIBFTS`, `LIBOBSTACK`, `LIBARGP`)
  * internal helper symbols hidden

---

## 5. Testing & validation strategy

### 5.1 Behavioral tests

For each API:

* **FTS tests**

  * Deterministic directory trees created under `tests/fixtures/fts/`
  * Test all combinations of flags:

    * logical vs physical vs `COMFOLLOW`
    * `NOCHDIR`, `XDEV`, `NOSTAT`
  * Verify traversal order and `FTSENT->fts_info` sequence against:

    * a glibc+gnulib based reference binary, or a NetBSD VM build using system `fts`

* **obstack tests**

  * Grow and shrink random-sized objects; compare to an in-memory model of contiguous allocation
  * Exercise `obstack_free` on:

    * `NULL`
    * object in head chunk
    * object in older chunk
  * Swap in a custom allocator that tracks chunk sizes and counts to ensure hook usage is correct

* **argp tests**

  * Mirror glibc argp examples and gnulib's tests: hierarchical parsers, error cases, `--help` output formatting([GitHub][10])
  * Capture help text and compare to golden files (allowing minor whitespace differences if needed)
  * Exercise `ARGP_HELP_FMT` in env for different widths

### 5.2 ABI tests

* For each library, build a **reference shared object** on a BSD / glibc system with the same headers
* Use `pahole` / `readelf -s` / `nm` to:

  * Assert **identical symbol names** and types
  * Assert **identical struct layout** (field offsets, sizes) for:

    * `FTS`
    * `FTSENT`
    * `struct obstack`
    * `struct argp`, `argp_option`, `argp_state`
* Add a CI job that fails if ABI changes (detect via `abi-compliance-checker` or a simple scripted diff of `pahole` output)

---

## 6. Integration guidelines (packagers, embedded)

**On musl systems**

* Install into the standard locations:

  * libs: `/usr/lib/libfts.so`, `/usr/lib/libobstack.so`, `/usr/lib/libargp.so`
  * headers: `/usr/include/fts.h`, `/usr/include/obstack.h`, `/usr/include/argp.h`, `/usr/include/queue.h`, `/usr/include/tree.h`, `/usr/include/cdefs.h`

* Make it easy for distros that already ship:

  * `musl-fts`
  * `musl-obstack`
  * `argp-standalone`

  to **replace** those packages with `musl-bsd` by providing `Provides:` metadata and compatible SONAMEs([GitHub][11])

**Cross & embedded**

* Keep syscalls minimal and configurable:

  * allow replacing `openat`, `fstatat`, etc in a portability shim if an embedded libc lacks them
* For obstack:

  * document how to plug in region allocators or arena allocators, so embedded systems can use fixed memory pools

---

## 7. Contribution rules

What you already have plus some sharpened requirements:

* Changes that touch **public headers** must:

  * be accompanied by a test
  * update an `API-CHANGES.md` with a one-line note
* Any change that can affect **ABI**:

  * must include ABI report in commit message (struct layout changes, symbol additions/removals)
* Commit style:

  * `area: imperative summary`
  * `area` values like `fts`, `obstack`, `argp`, `queue`, `cdefs`, `meson`, `tests`, `docs`
* Patches that "simplify" code by making it glibc-specific are rejected by default; everything must remain clean on musl and other libcs.

---

[1]: https://man.netbsd.org/fts.3 "fts(3) - NetBSD Manual Pages"
[2]: https://github.com/coreutils/gnulib/blob/master/lib/obstack.c "gnulib/lib/obstack.c at master"
[3]: https://sourceware.org/glibc/manual/latest/html_node/Argp-Parsers.html "Argp Parsers (The GNU C Library)"
[4]: https://github.com/openbsd/src/blob/master/sys/sys/queue.h "src/sys/sys/queue.h at master Â· openbsd/src"
[5]: https://github.com/void-linux/musl-fts "Implementation of fts(3) for musl libc packages in Void Linux"
[6]: https://wiki.musl-libc.org/faq "FAQ"
[7]: https://codebrowser.dev/glibc/glibc/malloc/obstack.h.html "obstack.h source code [glibc/malloc ..."
[8]: https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_node/libc_42.html "The GNU C Library - Creating Obstacks"
[9]: https://repology.org/project/argp-standalone/packages "argp-standalone packages"
[10]: https://github.com/coreutils/gnulib/blob/master/lib/argp-parse.c "gnulib/lib/argp-parse.c at master"
[11]: https://github.com/void-linux/musl-fts/blob/master/README.md "README.md - void-linux/musl-fts"
